"use strict";(self.webpackChunkdoris_website=self.webpackChunkdoris_website||[]).push([[5943],{15680:(e,t,n)=>{n.d(t,{xA:()=>c,yg:()=>y});var r=n(296540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var d=r.createContext({}),s=function(e){var t=r.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(d.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},g=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,d=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=s(n),g=a,y=u["".concat(d,".").concat(g)]||u[g]||p[g]||i;return n?r.createElement(y,l(l({ref:t},c),{},{components:n})):r.createElement(y,l({ref:t},c))}));function y(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=g;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o[u]="string"==typeof e?e:a,l[1]=o;for(var s=2;s<i;s++)l[s]=n[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}g.displayName="MDXCreateElement"},981292:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>s});var r=n(58168),a=(n(296540),n(15680));const i={title:"Sort Key and Prefix Index",language:"en"},l=void 0,o={unversionedId:"table-design/index/prefix-index",id:"version-2.0/table-design/index/prefix-index",title:"Sort Key and Prefix Index",description:"\x3c!--",source:"@site/versioned_docs/version-2.0/table-design/index/prefix-index.md",sourceDirName:"table-design/index",slug:"/table-design/index/prefix-index",permalink:"/docs/2.0/table-design/index/prefix-index",draft:!1,tags:[],version:"2.0",frontMatter:{title:"Sort Key and Prefix Index",language:"en"},sidebar:"docs",previous:{title:"Index Overview",permalink:"/docs/2.0/table-design/index/index-overview"},next:{title:"BloomFilter Index",permalink:"/docs/2.0/table-design/index/bloomfilter"}},d={},s=[{value:"Example",id:"example",level:2},{value:"Multiple prefix indexes",id:"multiple-prefix-indexes",level:2}],c={toc:s},u="wrapper";function p(e){let{components:t,...n}=e;return(0,a.yg)(u,(0,r.A)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("p",null,"Doris stores data in a data structure similar to SSTable (Sorted String Table), which is an ordered data structure that can sort and store data according to specified columns. Performing queries based on sorted columns in this data structure is highly efficient."),(0,a.yg)("p",null,"In the three data models of Aggregate, Unique, and Duplicate, the underlying data storage is sorted and stored according to the columns specified in the AGGREGATE KEY, UNIQUE KEY, and DUPLICATE KEY of their respective table creation statements. These keys are referred to as Sort Keys. With the help of Sort Keys, Doris can quickly find the data to be processed by specifying conditions on the sorted columns during queries, reducing the complexity of searching and thus accelerating the queries without the need to scan the entire table."),(0,a.yg)("p",null,"Based on the Sort Keys, Prefix Indexes are introduced. A Prefix Index is a sparse index. In the table, a logical data block is formed according to the corresponding number of rows. Each logical data block stores an index entry in the Prefix Index table. The length of the index entry does not exceed 36 bytes, and its content is the prefix composed of the sorted columns of the first row of data in the data block. When searching the Prefix Index table, it can help determine the starting row number of the logical data block where the row data is located. Because the Prefix Index is relatively small, it can be fully cached in memory, allowing for rapid data block localization and significantly improving query efficiency."),(0,a.yg)("admonition",{type:"tip"},(0,a.yg)("p",{parentName:"admonition"},"The first 36 bytes of a row of data in a data block serve as the prefix index for that row. When encountering a ",(0,a.yg)("inlineCode",{parentName:"p"},"VARCHAR")," type, the prefix index will be truncated directly. If the first column is of the ",(0,a.yg)("inlineCode",{parentName:"p"},"VARCHAR")," type, truncation will occur even if the length does not reach 36 bytes.")),(0,a.yg)("h2",{id:"example"},"Example"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"If the sort keys of the table are as follows: 5 columns, then the prefix index would be: user_id (8 Bytes), age (4 Bytes), message (prefix 20 Bytes).")),(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"ColumnName"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"user_id"),(0,a.yg)("td",{parentName:"tr",align:null},"BIGINT")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"age"),(0,a.yg)("td",{parentName:"tr",align:null},"INT")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"message"),(0,a.yg)("td",{parentName:"tr",align:null},"VARCHAR(100)")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"max_dwell_time"),(0,a.yg)("td",{parentName:"tr",align:null},"DATETIME")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"min_dwell_time"),(0,a.yg)("td",{parentName:"tr",align:null},"DATETIME")))),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"If the sort keys of the table consist of 5 columns and the first column is ",(0,a.yg)("inlineCode",{parentName:"li"},"user_name")," of the VARCHAR type, then the prefix index would be ",(0,a.yg)("inlineCode",{parentName:"li"},"user_name")," (truncated to 20 Bytes). Even though the total size of the prefix index has not reached 36 bytes, truncation occurs because it encounters a VARCHAR column, and no further columns are included.")),(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"ColumnName"),(0,a.yg)("th",{parentName:"tr",align:null},"Type"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"user_name"),(0,a.yg)("td",{parentName:"tr",align:null},"VARCHAR(20)")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"age"),(0,a.yg)("td",{parentName:"tr",align:null},"INT")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"message"),(0,a.yg)("td",{parentName:"tr",align:null},"VARCHAR(100)")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"max_dwell_time"),(0,a.yg)("td",{parentName:"tr",align:null},"DATETIME")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"min_dwell_time"),(0,a.yg)("td",{parentName:"tr",align:null},"DATETIME")))),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"When our query conditions match the prefix index, it can greatly accelerate the query speed. For example, in the first case, executing the following query:")),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"SELECT * FROM table WHERE user_id=1829239 and age=20\uff1b\n")),(0,a.yg)("p",null,"The efficiency of that query would be much higher than the following query:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre"},"SELECT * FROM table WHERE age=20\uff1b\n")),(0,a.yg)("p",null,"Therefore, when creating a table, selecting the correct order of columns can greatly enhance query efficiency."),(0,a.yg)("h2",{id:"multiple-prefix-indexes"},"Multiple prefix indexes"),(0,a.yg)("p",null,"Due to the specified column order during table creation, a table typically has only one type of prefix index. This may not meet the efficiency requirements for queries that use other columns as conditions, which do not hit the prefix index. In such cases, multiple prefix indexes can be indirectly implemented by creating corresponding strongly consistent materialized views of the single table with adjusted column orders. For more details, please refer to  ",(0,a.yg)("a",{parentName:"p",href:"../../query/view-materialized-view/materialized-view"},"Materialized Views"),"."))}p.isMDXComponent=!0}}]);